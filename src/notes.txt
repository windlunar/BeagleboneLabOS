//.thumb
//.syntax unified

//.equ CM_PER_GPIO1_CLKCTRL, 0x44e000AC
//.equ GPIO1_OE, 0x4804C134
//.equ GPIO1_SETDATAOUT, 0x4804C194
//.equ CONF_UART0_RXD, 0x44E10970
//.equ CONF_UART0_TXD, 0x44E10974
//.equ CM_WKUP_CLKSTCTRL, 0x44E00400
//.equ CM_PER_L4HS_CLKSTCTRL, 0x44E0011C
//.equ CM_WKUP_UART0_CLKCTRL, 0x44E004B4
//.equ CM_PER_UART0_CLKCTRL, 0x44E0006C
//.equ UART0_SYSC, 0x44E09054
//.equ UART0_SYSS, 0x44E09058
.equ UART0_BASE, 0x44E09000

/**
 * 
 * CPSR : Current Program Status Register.
 * Bits	Name	Function
 * [31]	N	Negative condition code flag
 * [30]	Z	Zero condition code flag
 * [29]	C	Carry condition code flag
 * [28]	V	Overflow condition code flag
 * [27]	Q	Cumulative saturation bit
 * [26:25]	IT[1:0]	If-Then execution state bits for the Thumb IT (If-Then) instruction
 * [24]	J	Jazelle bit
 * [19:16]	GE	Greater than or Equal flags
 * [15:10]	IT[7:2]	If-Then execution state bits for the Thumb IT (If-Then) instruction
 * [9]	E	Endianness execution state bit: 0 - Little-endian, 1 - Big-endian
 * [8]	A	Asynchronous abort mask bit
 * [7]	I	IRQ mask bit
 * [6]	F	FIRQ mask bit
 * [5]	T	Thumb execution state bit
 * [4:0]	M	Mode field
 */ 

/** 
 * CPSR MODE FIELD :
 * 
 * #define 	CPSR_M_USR   0x10U
 * CPSR: M User mode (PL0)
 * 
 * #define 	CPSR_M_FIQ   0x11U
 * CPSR: M Fast Interrupt mode (PL1)
 * 
 * #define 	CPSR_M_IRQ   0x12U
 * CPSR: M Interrupt mode (PL1)
 * 
 * #define 	CPSR_M_SVC   0x13U
 * CPSR: M Supervisor mode (PL1)
 * 
 * #define 	CPSR_M_MON   0x16U
 * CPSR: M Monitor mode (PL1) 
 * 
 * #define 	CPSR_M_ABT   0x17U
 * CPSR: M Abort mode (PL1) 
 * 
 * #define 	CPSR_M_HYP   0x1AU
 * CPSR: M Hypervisor mode (PL2) 
 * 
 * #define 	CPSR_M_UND   0x1BU
 * CPSR: M Undefined mode (PL1) 
 */ 



_start:
   	mrs 	r0, cpsr 				//mrs:讀取狀態reg到r0, cpsr : Current Program Status Register. 
   	bic 	r0, r0, #0x1F 				//將r0的bits [4:0]清除
   	orr 	r0, r0, #0x13 				//將r0與0x13(b10011)作OR運算,然後存回r0, Set SVC mode
   	orr 	r0, r0, #0xC0 				//Disable FIQ and IRQ ,0xC0 =b1100-0000
   	msr 	cpsr, r0				//將設定好的r0存回cpsr

	ldr 	sp, =0x90000000 	 		//Set the stack pointer


	b 		SET_UART0_BASE

.loop: 
	b 		.loop





/* Set UART0 base address */
SET_UART0_BASE:
    ldr 	r1, =0x44E09000

    ldr 	r0, =0x12abcdef
	//mrc 	p15, 0, r0, c1, C0, 0	//Read CP15 c1 to r0 , for c1 bit0 = 0 : disable MMU
	//mrs 	r0, cpsr

	mov 	r3, r0				
	ldr 	r4, =0					//Set counter in the loop
	
PRINT_REG:
	and 	r0, r3, #0xf0000000		//r3是要印出的值 ,先傳送bit[31:28]:跟0xf0000000 and ,存到r0 
	LSL 	r3, r3, #0x04			//左移四位以印出 bit[27:24] ,之後依此類推...
	LSR 	r0, r0, #28				//r0右移28位	

	cmp		r0, #0x09				//判斷是否是abcdef
	bcs		ABCDEF

	add 	r0, r0, #0x30			//r0加0x30變成 ASCII
	b 		PUT

PUT:
	bl 		.uart_putc
	
	add 	r4, r4, #0x1
    cmp  	r4 , #0x08        		//判斷 i 是否等於val       if(i==val)
    bne    	PRINT_REG         		//若不相等 跳轉至tx_reg處進入下次迴圈     else continue
	b 		.loop

ABCDEF:
	add 	r0, r0, #0x57			//變成 ASCII
	b		PUT


.uart_putc:
    ldrb    r2, [r1, #20]
    uxtb    r2, r2
    tst     r2, #32
    beq     .uart_putc
    strb    r0, [r1]
    bx      lr


